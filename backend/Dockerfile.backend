FROM node:20-alpine

# Set working directory inside the container
WORKDIR /app/backend

# Install build tools for node-pty (these are temporary during build)
# Node-pty has native C++ bindings that need to be compiled.
RUN apk add --no-cache python3 make g++

# Copy package.json and package-lock.json first
# This allows Docker to cache the npm install layer
COPY package*.json ./

# Install Node.js dependencies
# This is where node-pty gets compiled for THIS Node.js version in the container
RUN npm install

# Remove build tools to keep the final image small
RUN apk del python3 make g++

# Copy the rest of your backend application code
COPY . .

# Expose the port your Express server listens on
EXPOSE 3000

# Command to run the application using PM2 (installed as a dev dependency or globally if preferred)
# If PM2 is in devDependencies, ensure it's installed globally during build: npm install -g pm2
# Or just run 'node server.js' and PM2 will be handled by the host orchestrator.
# For simplicity and robust internal management, we'll install PM2 globally here.
RUN npm install -g pm2

# Define the command that starts your app with PM2
# PM2 needs to be started in non-daemonized mode or the container will exit
CMD ["pm2-runtime", "server.js", "--name", "web-terminal-backend"]